from typing import Literal, List, Dict
from pydantic import BaseModel, Field
from langchain.output_parsers import PydanticToolsParser
from langchain_core.prompts import ChatPromptTemplate
from langchain.chat_models import ChatOpenAI
from langchain.schema import SystemMessage, HumanMessage
import json
from config import load_config

config = load_config()

# Initialize the OpenAI chat model
llm = ChatOpenAI(openai_api_key=config["OPENAI_API_KEY"], model="gpt-3.5-turbo-0125", temperature=0)

# Metadata and Transcript fields description
metadata_fields = """
- Call Length: The duration of the call in seconds.
- Lead Id: Unique identifier for the lead.
- Call DateTime: The date and time when the call took place.
- Language of the call: The language in which the call was conducted. Valid values are ['Hindi', 'Marathi'].
- Purpose: The purpose of the call, such as 'Construction', 'Other Loans - Home Equity', 'Purchase', etc.
- Product offered: The product offered during the call.
- Lead Source: The source from which the lead was generated, such as 'PhonePe', 'Google Ads', 'Self Sourced', etc.
- Location: The location of the customer.
- Branch: The branch associated with the lead.
- Opportunity Created: Indicates if an opportunity was created from the call.
- Business Created: Indicates if a business was created from the call.
- Agent Name: The name of the agent handling the call.
- Agent ID: Unique identifier for the agent.
"""
transcript_fields = "Call transcripts Recordings where it records who has said what"

# Define filtering function
def choose_filtering_function(query: str) -> str:
    filtering_messages = [
        SystemMessage(content=f"""
        You are an expert in selecting the filtering function.
        Choose "metadata_filtering" if the query is focused on metadata characteristics of a call recording( e.g. call duration, lead_source, etc), 
        and "transcript_filtering" if the query is focused on conversation happened during call.(like who said what, why in call)
        Respond in JSON format as:
        {{
            "filtering_function": "<selected_function>"
        }}
        """),
        HumanMessage(content=query)
    ]
    response = llm(filtering_messages)
    try:
        result = json.loads(response.content)
        return result["filtering_function"]
    except (json.JSONDecodeError, KeyError):
        raise ValueError(f"Unexpected response format: {response.content}")

# Define analysis function
def choose_analysis_function(query: str) -> str:
    analysis_messages = [
        SystemMessage(content="""
        You are an expert in selecting the analysis level required to answer the question.
        If the question is more analytical like find me count,etc around call characterestic,
        then Choose "metadata_analysis" for a numerical summary, If question is around who said what, why, reasoning kind of questions, then 
        Choose "general_analysis" for a broad summary based question , 
        and "detailed_analysis" for an in-depth detailed type question.
        Respond in JSON format as:
        {
            "analysis_function": "<selected_function>"
        }
        """),
        HumanMessage(content=query)
    ]
    response = llm(analysis_messages)
    try:
        result = json.loads(response.content)
        return result["analysis_function"]
    except (json.JSONDecodeError, KeyError):
        raise ValueError(f"Unexpected response format: {response.content}")

# Define reporting function
def choose_reporting_function(query: str) -> str:
    reporting_messages = [
        SystemMessage(content="""
        You are an expert in selecting the reporting format required to answer the question.
        Choose "Pointers" for a bullet-point response, 
        and "Summary" for a concise summary.
        Respond in JSON format as:
        {
            "reporting_function": "<selected_function>"
        }
        """),
        HumanMessage(content=query)
    ]
    response = llm(reporting_messages)
    try:
        result = json.loads(response.content)
        return result["reporting_function"]
    except (json.JSONDecodeError, KeyError):
        raise ValueError(f"Unexpected response format: {response.content}")

def module_chooser(sub_queries: List[str]) -> Dict[str, Dict[str, str]]:
    """
    Routes each sub-query to the relevant functions in the Filtering, Analysis, and Reporting modules.
    
    :param sub_queries: List of sub-queries generated by analyze_query.
    :return: Dictionary with each sub-query mapped to selected functions across the three modules.
    """
    routed_functions = {}

    for query in sub_queries:
        # Select functions from each module separately
        filtering_function = choose_filtering_function(query)
        analysis_function = choose_analysis_function(query)
        reporting_function = choose_reporting_function(query)
        
        # Store the results for each query
        routed_functions[query] = {
            "filtering_function": filtering_function,
            "analysis_function": analysis_function,
            "reporting_function": reporting_function
        }
    
    return routed_functions
